<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Блог TinyOps - docker</title>
	<subtitle>О технологиях, подходах и решении проблем простым языком</subtitle>
	<link href="https://b.tinyops.ru/tags/docker/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://b.tinyops.ru"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2021-08-10T00:00:00+00:00</updated>
	<id>https://b.tinyops.ru/tags/docker/atom.xml</id>
	<entry xml:lang="en">
		<title>Как добавить самоподписной SSL-сертификат для JVM в Docker</title>
		<published>2021-08-10T00:00:00+00:00</published>
		<updated>2021-08-10T00:00:00+00:00</updated>
		<link href="https://b.tinyops.ru/kak-to-install-self-signed-ssl-cert-in-docker/" type="text/html"/>
		<id>https://b.tinyops.ru/kak-to-install-self-signed-ssl-cert-in-docker/</id>
		<content type="html">&lt;p&gt;Представим что у нас есть Java-приложение, которое делает запросы к другим Web-сервисам. В свою очередь, Web-сервисы работают с HTTPS, но сертификат доверенный только для домена компании.&lt;&#x2F;p&gt;
&lt;p&gt;В логах приложения подобные ошибки:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.ssl.Alert.createSSLException(Alert.java:131)
    at sun.security.ssl.TransportContext.fatal(TransportContext.java:324)
    at sun.security.ssl.TransportContext.fatal(TransportContext.java:267)
    at sun.security.ssl.TransportContext.fatal(TransportContext.java:262)
    at sun.security.ssl.CertificateMessage$T12CertificateConsumer.checkServerCerts(CertificateMessage.java:654)
    at sun.security.ssl.CertificateMessage$T12CertificateConsumer.onCertificate(CertificateMessage.java:473)
    at sun.security.ssl.CertificateMessage$T12CertificateConsumer.consume(CertificateMessage.java:369)
    at sun.security.ssl.SSLHandshake.consume(SSLHandshake.java:377)
    at sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:444)
    at sun.security.ssl.HandshakeContext.dispatch(HandshakeContext.java:422)
    at sun.security.ssl.TransportContext.dispatch(TransportContext.java:182)
    at sun.security.ssl.SSLTransport.decode(SSLTransport.java:152)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Нам необходимо добавить самоподписной корневой сертификат в хранилище сертификатов JVM.&lt;&#x2F;p&gt;
&lt;p&gt;В JVM сертификаты хранятся в файле-хранилище &lt;code&gt;${JAVA_HOME}&#x2F;jre&#x2F;lib&#x2F;cacerts&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Находим где располагается JVM, для этого заходим в контейнер приложения:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it app &#x2F;bin&#x2F;bash
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;и ищем:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;root@458b6bbf28b5:&#x2F;app# whereis java
java: &#x2F;usr&#x2F;local&#x2F;openjdk-8&#x2F;bin&#x2F;java
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Соответственно, наш &lt;code&gt;JAVA_HOME&lt;&#x2F;code&gt; это &lt;code&gt;&#x2F;usr&#x2F;local&#x2F;openjdk-8&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Теперь выходим из контейнера и копируем каталог &lt;code&gt;security&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;docker cp app:&#x2F;usr&#x2F;local&#x2F;openjdk-8&#x2F;jre&#x2F;lib&#x2F;security .
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Правим &lt;code&gt;docker-compose.yml&lt;&#x2F;code&gt; для проброса каталога внутрь контейнера:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;version: &#x27;3.3&#x27;

services:

  app:
    container_name: app
    image: registry.company.ru&#x2F;app:1.3.7-12
    restart: always
    volumes:
     - .&#x2F;application.properties:&#x2F;app&#x2F;application.properties
     - .&#x2F;data:&#x2F;app&#x2F;data
     - .&#x2F;logs:&#x2F;app&#x2F;logs
     - .&#x2F;security:&#x2F;usr&#x2F;local&#x2F;openjdk-8&#x2F;jre&#x2F;lib&#x2F;security
    ports:
     - &quot;35000:8080&quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Добавляем сертификат в файл &lt;code&gt;cacerts&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;keytool -importcert -keystore security&#x2F;cacerts -file custom-ca.crt -alias &quot;custom-ca&quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Пароль по умолчанию для доступа в хранилище &lt;code&gt;changeit&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Рестартуем приложение:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;docker-compose down
docker-compose up -d
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Как развернуть php приложение в Docker</title>
		<published>2020-04-04T00:00:00+00:00</published>
		<updated>2020-04-04T00:00:00+00:00</updated>
		<link href="https://b.tinyops.ru/run-php-in-docker/" type="text/html"/>
		<id>https://b.tinyops.ru/run-php-in-docker/</id>
		<content type="html">&lt;p&gt;По ходу работы мне потребовалось мигрировать тройку php-приложений на новый сервер. На старом сервере был CentOS 6, зоопарк софта и набор
недокументированных хаков. Т.к. я из мира JVM-языков, то мир php для меня чужой. 
Чтобы минимизировать себе психологический урон в будущем, я решил собрать docker образ для каждого из приложений. &lt;&#x2F;p&gt;
&lt;p&gt;Такое оборачивание дает дополнительное преимущество - если кто-то хакнул приложение, 
то можно без привлечения внешних security-средств (например, tripwire) легко сдампить текущее состояние в файл, откатить
до нехакнутого варианта. А дальше уже звать разработчиков и пусть роются в дампе :))&lt;&#x2F;p&gt;
&lt;p&gt;За основу я взял образ с php 5.6 + Apache. Приложения требовали &lt;code&gt;ImageMagick&lt;&#x2F;code&gt;, &lt;code&gt;gd&lt;&#x2F;code&gt; и &lt;code&gt;zip&lt;&#x2F;code&gt;, 
поэтому добавил их через скрипт &lt;code&gt;docker-php-ext-install&lt;&#x2F;code&gt;. Также требовалось установить
часовой пояс сервера, сделал это классическим &lt;code&gt;echo&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Перед сборкой скопировал файлы приложения в подкаталог &lt;code&gt;app&lt;&#x2F;code&gt;. &lt;&#x2F;p&gt;
&lt;p&gt;Файл сценария сборки - &lt;code&gt;Dockerfile&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;dockerfile&quot; class=&quot;language-dockerfile &quot;&gt;&lt;code class=&quot;language-dockerfile&quot; data-lang=&quot;dockerfile&quot;&gt;FROM php:5.6-apache

RUN apt-get update &amp;&amp; apt-get install -y \
                      libmagickwand-dev --no-install-recommends \
                   &amp;&amp; pecl install imagick \
        &amp;&amp; docker-php-ext-enable imagick

RUN apt-get update &amp;&amp; apt-get install -y \
        libfreetype6-dev \
        libjpeg62-turbo-dev \
        libpng-dev \
    &amp;&amp; docker-php-ext-configure gd --with-freetype --with-jpeg \
    &amp;&amp; docker-php-ext-install -j$(nproc) gd \
    &amp;&amp; docker-php-ext-install -j$(nproc) zip

RUN echo &quot;date.timezone = Europe&#x2F;Moscow&quot; &gt; &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;conf.d&#x2F;timezone.ini

RUN a2enmod rewrite
RUN service apache2 restart
COPY app&#x2F; &#x2F;var&#x2F;www&#x2F;html

RUN usermod -u 1001 www-data &amp;&amp; groupmod -g 1001 www-data

RUN chown -R www-data.www-data &#x2F;var&#x2F;www
RUN chmod -R ug=rwx &#x2F;var&#x2F;www

RUN mkdir &#x2F;tmp&#x2F;webmodule
RUN chmod a=rwx &#x2F;tmp&#x2F;webmodule
EXPOSE 80

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Собираем:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;shell script&quot; class=&quot;language-shell script &quot;&gt;&lt;code class=&quot;language-shell script&quot; data-lang=&quot;shell script&quot;&gt;docker build -t my-repo&#x2F;my-app:1.0.0 .
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;kak-dobavliat-rasshireniia-dlia-php&quot;&gt;Как добавлять расширения для php&lt;&#x2F;h2&gt;
&lt;p&gt;Авторы PHP любезно предоставили скрипт &lt;code&gt;docker-php-ext-install&lt;&#x2F;code&gt; внутри базового контейнера. В примере выше видно как это
использовать.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kak-ispol-zovat-svoi-php-ini&quot;&gt;Как использовать свой php.ini&lt;&#x2F;h2&gt;
&lt;p&gt;Добавляем в &lt;code&gt;Dockerfile&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;COPY php.ini &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;kak-reshit-problemu-s-pravami-dostupa&quot;&gt;Как решить проблему с правами доступа&lt;&#x2F;h2&gt;
&lt;p&gt;В &lt;code&gt;Dockerfile&lt;&#x2F;code&gt; есть пара команд, которые дают полные права для пользователя &lt;code&gt;www-data&lt;&#x2F;code&gt;, 
а также задают ID пользователя и группы для него равные &lt;code&gt;1001&lt;&#x2F;code&gt;.
На хосте где крутится докер я создал юзера с таким же uid\gid и сделал его полноправным владельцем папки 
которую использую как volume:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;...
volumes:
      - .&#x2F;storage:&#x2F;var&#x2F;www&#x2F;html&#x2F;data
...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;kak-ispol-zovat&quot;&gt;Как использовать&lt;&#x2F;h2&gt;
&lt;p&gt;С помощью docker compose можно завести вот так:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;yaml&quot; class=&quot;language-yaml &quot;&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;version: &#x27;2&#x27;

services:
  phpfpm:
    image: &quot;my-repo&#x2F;my-app:1.0.0&quot;
    volumes:
      - .&#x2F;storage:&#x2F;var&#x2F;www&#x2F;html&#x2F;data
    ports:
      - &quot;9123:80&quot;
    environment:
      - APACHE_RUN_USER=#1001
      - APACHE_RUN_GROUP=#1001
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Чтобы данные которые загружают юзеры сохранялись делаем volume.&lt;&#x2F;p&gt;
&lt;p&gt;Стартуем:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;shell script&quot; class=&quot;language-shell script &quot;&gt;&lt;code class=&quot;language-shell script&quot; data-lang=&quot;shell script&quot;&gt;docker-compose up -d
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Приложение будет доступно на порту &lt;code&gt;9123&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
